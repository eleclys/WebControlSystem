# 前端+后端分离应用
server {
    listen 80;  # Nginx 监听 80 端口（HTTP 默认端口）
    # 当有请求访问服务器的 80 端口时，这个 server 块就会处理该请求
    # 如果想监听 HTTPS，需要改成 listen 443 ssl; 并配置 SSL 证书

    server_name localhost;  # 设置服务器名为 localhost，表示这个配置主要用于本地开发环境（通过 http://localhost 访问）或者作为默认服务器（当没有其他 server_name 匹配时）
    # 生产环境中通常会改成真实域名
    # 当有多个 server 块时，Nginx 会通过 server_name 来匹配配置

    location / {    # 是 Nginx 配置中处理根路径请求的核心指令，通常用于部署单页应用（如 Vue/React/Angular）
        # 前端路由：SPA 的路由（如 /about, /contact）是虚拟路径，实际文件只有 index.html。
        # 静态资源：CSS/JS/图片等真实文件需要被正常返回。

        root /usr/share/nginx/html;  # 设置静态文件的根目录为 /usr/share/nginx/html
        # 当访问 http://localhost/js/app.js 时，Nginx 会返回文件：/usr/share/nginx/html/js/app.js
        # 注意，若静态文件路径变化，需要改root的路径
        # 注意root和alias的区别：root 会将 location 路径拼接到目录后（如上例）。alias 会直接替换 location 路径（需精确匹配）。
        index index.html;  # 指定默认索引文件为 index.html
        # 当访问目录路径（如 http://localhost/）时，Nginx 会自动尝试返回该目录下的 index.html 文件。
        # 相当于自动补全路径为 /usr/share/nginx/html/index.html。
        try_files $uri $uri/ /index.html;  # 这是单页应用（SPA）的关键配置
        # $uri：尝试直接匹配请求的路径对应的文件（如 /css/style.css）。
        # $uri/：尝试将路径当作目录，看看这个“目录”下有没有index.html（触发 index 指令）。
        # /index.html：若以上均失败，最终回退到返回 index.html（由前端路由处理）。
        # 注意，Nginx 只是在服务器内部将请求交给了 index.html 处理，并不是重定向
        # try_files 确保了：真实文件存在时直接返回该文件（如静态资源）。虚拟路径回退到 index.html，交给前端路由处理。
        # 若无try_files，访问 /about 会返回 404，因为 Nginx 找不到 /about 对应的文件或目录。
        # 工作流程：
        # 1. 用户访问 http://localhost/user/profile：
            # 先检查是否存在文件 /usr/share/nginx/html/user/profile → 不存在。
            # 再检查是否存在目录 /usr/share/nginx/html/user/profile/ → 不存在。
            # 最终返回 /usr/share/nginx/html/index.html，由前端 JavaScript 处理路由。
        # 2. 用户访问 http://localhost/logo.png：
            # 若文件 /usr/share/nginx/html/logo.png 存在，则直接返回该文件。
    }

    # 反向代理，所有以 /api/ 开头的请求，转发到后端的Flask应用服务器（运行在flask-backend:8000）
    # 如，http://localhost/api/users 实际请求 http://flask-backend:8000/api/users
    location /api/ {
        proxy_pass http://flask-backend:8000;   # 代理目标，也就是要把请求转发给谁（通常是另一个容器或服务的内部地址）
        proxy_http_version 1.1;  # 强制使用 HTTP/1.1 协议与后端通信（默认是 HTTP/1.0），为了支持Keep-Alive 长连接（提升性能）、WebSocket 或 gRPC 等高级协议

        # 下面的proxy_set_header 系列，用于修改或添加转发给后端的请求头，确保后端能获取正确的客户端信息
        proxy_set_header Host $host;    # 保留原始请求的域名
        # 解决路径问题。默认情况下，Nginx 转发时会去掉 /api/ 前缀（若需保留，需用 proxy_pass http://flask-backend:8000/api/;）。
        # 当前配置会保留原始路径（如 /api/users → 后端仍收到 /api/users）。

        proxy_set_header X-Real-IP $remote_addr;    # 传递客户端的真实 IP
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;    # 追加客户端 IP 到代理链（用于追踪多级代理）
        # 后端获取真实客户端信息
        # 直接访问后端时，Flask 可以通过 request.remote_addr 获取客户端 IP。
        # 但通过 Nginx 代理后，后端看到的 IP 会是 Nginx 容器的内网 IP（如 172.17.0.1），因此需要 X-Real-IP 或 X-Forwarded-For 传递真实 IP。

        proxy_set_header X-Forwarded-Proto $scheme; # 告知后端原始请求的协议（HTTP/HTTPS）
        # 协议一致性。如果 Nginx 启用了 HTTPS，而后端是 HTTP，X-Forwarded-Proto 会告知 Flask 原始请求是加密的，方便生成正确的 URL（如 url_for() 生成 HTTPS 链接）。
    }


    # WebSocket 支持 (用于 /socket.io/)
    # 专门用于支持 WebSocket 协议的代理设置，通常用于维持长连接，实现实时双向通信（如在线聊天、实时数据推送等）
    # 将 /socket.io/ 开头的请求（WebSocket 连接）透明转发到后端的 Flask 服务（运行在 flask-backend:8000），
    # 同时确保 WebSocket 协议能正常握手和保持连接
    location /socket.io/ {
        proxy_pass http://flask-backend:8000;   # 代理目标，也就是要把请求转发给谁
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade; # 将客户端的 Upgrade 头（值通常是 websocket）原样传递给后端。
        # WebSocket 握手：客户端发送 Upgrade: websocket 头，表示希望升级到 WebSocket 协议。

        proxy_set_header Connection "upgrade";
        # 关键作用：强制设置 Connection: upgrade 头，告知后端同意协议升级。
        # 与普通 HTTP 的区别：普通请求的 Connection 头通常是 keep-alive 或 close。

        proxy_set_header Host $host; # 保留原始请求的 Host 头（如 localhost），避免后端因域名丢失处理异常。
    }
    # 客户端先发送一个 HTTP 请求，包含 Upgrade: websocket 头。
    # 服务端返回 HTTP 101 Switching Protocols 响应，确认协议升级。
    # 此后连接变为双向通信的 WebSocket 长连接。
    # Nginx 默认会丢弃 Upgrade 和 Connection 头，导致 WebSocket 握手失败。必须显式配置这些头，才能让协议升级生效。
}
